<!DOCTYPE html>
<html lang="en">
<head>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
  <script src="bundle.js"></script>
  <meta charset="utf-8">
  <title>Financial Smart Contracts</title>
  <link rel="stylesheet" type="text/css" href="main.css" />
</head>
<body>
  <div id="outer_container">
    <h1>FSC</h1>
    <div id="top_container">
        <div id="top_input_container">
            <input id="holder_address" type="text" placeholder="Holder Address">
            <div id="collateral_container">
                <p id="collateral">Collateral</p>
                <select id="select_collateral" class="1_100" onchange="changeCollateral(getSelectedCollateral())"></select>
            </div>
            <input id="counter_party_address" type="text" placeholder="Counter-Party Address"><br>
        </div>
        <button class="button" id = "create_contract_button" type="button" onclick="instantiateNew()">Create Contract</button>
        <p class="status" id="contract_status"></p>
    </div>
    <div id="bottom_container">
      <div id="bottom_input_container">
          <div id="scalek_container">
              <p id="scalek">scaleK</p>
              <select id="select_scalek" class="1_100" onchange="changeScaleK(getSelectedScaleK())"></select>
          </div>
          <button class="button" id = "give_button" type="button" onclick="change_given()">give</button>
          <select id="select_one_zero" onchange="changeSelecteOneZero(getSelectedOneZero())">
              <option>one</option>
              <option>zero</option>
          </select><br>
      </div>
      <input id="transaction_input" type="text" placeholder="Transaction">
      <button class="button" id = "send_tx_id" type="button" onclick="makeTransaction(getInputString())">Make Transaction</button>
      <div id="button_choices_container"></div>
      <p class="status" id="transaction_status"></p>
    </div>
  </div>
  <script>
    $(function(){
        var $select = $(".1_100");
        for (i=1;i<=100;i++){
            $select.append($('<option></option>').val(i).html(i))
        }
    });

    function changeCollateral(collateralIn) {
        selectedCollateral = collateralIn;
    }

    function getSelectedCollateral() {
        return document.getElementById("select_collateral").value;
    }

    function removeChildren(containerString) {
        var e = document.getElementById(containerString);
        var child = e.lastElementChild;
        while (child) {
            e.removeChild(child);
            child = e.lastElementChild;
        }
    }

    function testReachability() {
        parse("( scaleK 50 ( get ( truncate \"24/12/2019-23:33:33\" ( give one ) ) ) ) or ( zero and truncate \"26/12/2019-23:33:33\" ( give zero ) )");
        removeChildren("button_choices_container");
        parse("( scaleK 50 ( get ( truncate \"24/12/2019-23:33:33\" ( give one ) ) ) ) or ( zero or truncate \"26/12/2019-23:33:33\" ( give zero ) )");
        removeChildren("button_choices_container");
        parse("( scaleK 50 ( get ( truncate \"24/12/2019-23:33:33\" ( give one ) ) ) ) or zero");
        removeChildren("button_choices_container");
        parse("zero or give one");
        removeChildren("button_choices_container");
        parse("( ( zero or give one ) or scaleK 10 ( one ) ) or zero");
        removeChildren("button_choices_container");
        parse("( zero or give one ) or ( scaleK 10 one or zero )");
        removeChildren("button_choices_container");
        parse("( zero or one ) or scaleK 10 ( one )");
        removeChildren("button_choices_container");
        parse("give one or ( ( truncate \"24/12/2019-23:33:33\" ( give zero ) ) and give zero )");
        removeChildren("button_choices_container");
        parse("( zero or give one ) or ( ( scaleK 10 one ) or zero )");
        removeChildren("button_choices_container");
        parse("( zero or give one ) or ( ( scaleK 10 ( one ) ) or zero )");
        removeChildren("button_choices_container");
        parse("give one or ( ( truncate \"24/12/2019-23:33:33\" ( give zero ) ) or give zero )");
        removeChildren("button_choices_container");
    }

    function makeTransaction(inputString) {
        removeChildren("button_choices_container");
        parse(inputString);
        //testReachability();
    }

    function getInputString() {
        return document.getElementById("transaction_input").value;
    }

    var stringToAddToBeginning = "";

    function checkSpacing(string) {
        // TODO: add regex matching that replaces every match with a spaced out parenthesis
        var matches1 = string.match(/^.*\S\(.*$/);
        var matches2 = string.match(/^.*\(\S.*$/);
        var matches3 = string.match(/^.*\S\).*$/);
        var matches4 = string.match(/^.*\)\S.*$/);

        if (matches1 !== null || matches2 !== null || matches3 !== null || matches4 !== null) {
            return false;
        } else {
            return true;
        }
    }

    function parse(inputString) {
      // check that spacing in user input is correct
      if (!checkSpacing(inputString)) {
          window.alert("Please provide a single space character before and after parenthesis in your input.");
          return;
      }
      stringToAddToBeginning = "";
      // check if inputstring contains 'or' else execute right away
      if (inputString.includes("or")) {
        var firstOpeningParenOcc = inputString.indexOf("(");
        var firstSubstring = inputString.slice(0, firstOpeningParenOcc);
        if (!firstSubstring.includes("or")) {
            inputString = inputString.slice(firstOpeningParenOcc, inputString.length);
            stringToAddToBeginning = firstSubstring;
        }
        var stack = [];
        var currentTerm = ""; //keeps track of the term ie and,give,one when initially looping through input & is used to add these to stack
        var currentConj = "";
        var conjunctionStack = []; // whenever stack is empty then conjunctionStack will be popped and used
        var contractString = ""; // used to accumulate the complete contract from its parts one by one when popping off the stack
        var contractsStack = [];
        var firstPartOfConjunction = "";
        var lastClosingParenPushedIndex = -1;
        var strArr = rTrimWhiteSpace(lTrimWhiteSpace(inputString)).split("");
        for (i = 0; i < strArr.length; ++i) {
              console.log("ContractString = " + contractString);
              str = strArr[i];
              console.log("iteration through array: " + i + ". Symbol: " + str);
              if (str === ")" || i === strArr.length - 1) { // i === strArr.length - 1 so that it also handles case where input does not end with ')'
                  if (i === strArr.length - 1 && str !== ")" && currentTerm !== " ") { // for 'give one or zero' case, ie when input does not end with closing paren
                      currentTerm += str;
                      console.log("Pushing last term - " + currentTerm + " - on stack.");
                      stack.push(currentTerm);
                  } else {

                      if (str === ")") {
                          // storing parenthesis and only appending at the end to avoid adding creating too many parenthesis in middle and leaving end one out
                          if (lastClosingParenPushedIndex !== -1
                           && openingParensAmount(inputString.slice(0, i + 1)) === closingParensAmount(inputString.slice(0, i + 1))
                           && lastClosingParenPushedIndex < strArr.length - 2
                           && (strArr[lastClosingParenPushedIndex + 2] === "a" || strArr[lastClosingParenPushedIndex + 2] === "o")) {

                          } else {
                              contractString += " )";
                          }
                          lastClosingParenPushedIndex = i;
                      }

                  }
                  currentTerm = "";
                  // pop while items off stack until discovered |)| == popped |(|
                  console.log("contractString initially: " + contractString);

                  while (stack.length > 0) {

                      var term = stack.pop();
                      console.log("Stack popping 1 - term: " + term);
                      if (term === "and" || term === "or") {
                          // if already have first and part then add it to it, else only add this to contractsStack
                          if (i == strArr.length - 1 && stack.length == 0) {
                              currentConj = "";
                              console.log("0.125: Pushing " + contractString + " to contractsStack");
                              contractsStack.push(contractString);
                              contractString = "";
                          }
                          else if ((stack.length == 0 || (stack.length == 1 && stack[0] === "(")) && conjunctionStack.length !== 0) { // add contractString to contractsStack.pop()
                              currentConj = "";
                              console.log("0.25: Pushing ... to contractsStack");
                              contractsStack.push(contractsStack.pop() + " " + conjunctionStack.pop() + " " + contractString);
                              contractString = "";

                          } else if (firstPartOfConjunction !== "") {
                              currentConj = "";
                              console.log("0.5: Pushing " + firstPartOfConjunction + " " + term + " " + contractString + " to contractsStack");
                              contractsStack.push(firstPartOfConjunction + " " + conjunctionStack.pop() + " " + contractString);
                              contractString = "";
                              firstPartOfConjunction = "";

                          } else {
                              currentConj = term;
                              console.log(stack.length);
                              console.log(stack[0]);
                              console.log(conjunctionStack.length);
                              console.log("1: Pushing " + contractString + " to contractsStack");
                              contractsStack.push(contractString);
                              contractString = "";
                          }
                      } else if (term === "(") {
                          contractString = term + " " + contractString;
                          console.log("currentConj: " + currentConj);

                          if (stack.length !== 0 && currentConj !== "") { // contracts string should be pushed to contracts stack not the combined string
                              console.log("1.5: Pushing ... to contractsStack");
                              console.log(contractString);
                              console.log(currentConj);
                              contractsStack.push(contractString + " " + conjunctionStack.pop() + " " + contractsStack.pop());
                              currentConj = "";
                              contractString = "";
                          }
                          break;

                      } else if (term === "zero" || term === "one") { //then add current contractString to contractsStack and start from empty contractString
                          if (contractString.includes("zero") || contractString.includes("one")) { // for '((give one) or give zero)' case
                              firstPartOfConjunction = contractString;
                              contractString = term;
                          } else {
                              contractString = term + " " + contractString;
                          }
                      } else {
                          console.log("In here baby 2");
                          contractString = term + " " + contractString;
                      }
                  }
                  console.log("contractString now = " + contractString);
                  printStack(stack, "termStack");
                  printStack(conjunctionStack, "conjunctionStack");
                  printStack(contractsStack, "contractsStack");

                  if (stack.length == 0 && contractString !== "" && contractString !== "( ") {

                      if (currentConj !== "" && i !== strArr.length - 1) {
                          console.log("1.75: Pushing ... to contractsStack");
                          contractsStack.push(contractString + " " + conjunctionStack.pop() + " " + contractsStack.pop());
                          currentConj = "";
                      } else { // if there is no currConj then we can just add this one
                          console.log("2: Pushing " + contractString + " to contractsStack");
                          contractsStack.push(contractString);
                      }
                      contractString = "";
                  }

              } else if (str === " ") {
                  // push term
                  if (currentTerm !== "") { // not needed
                      console.log("Pushing last term - " + currentTerm + " - on stack.");
                      stack.push(currentTerm);
                      if (currentTerm === "and" || currentTerm === "or") {
                          conjunctionStack.push(currentTerm);
                      }
                      currentTerm = "";
                  }
              } else if (str === "(") {
                  stack.push(str);
              } else {
                 // its part of term
                 currentTerm += str;
              }
              console.log("contractString now 2 = " + contractString);
          }
          // while stack.length > 0 repeat
          if (stack.length > 0) {
              while (stack.length > 0) {
                  var term = stack.pop();
                  console.log("Stack popping 2 - term: " + term);
                  if (term === "and" || term === "or") {
                      currentConj = term;
                      if (contractString !== "" && contractString !== "( ") {
                          if (lastClosingParenPushedIndex !== -1) {
                              contractString += " )";
                              lastClosingParenPushedIndex = -1;
                          }
                          console.log("5: Pushing " + contractString + " to contractsStack");
                          contractsStack.push(contractString);
                      }
                      contractString = ""; // to print out the whole contract when all its parts have been discovered
                  } else {
                      contractString = term + " " + contractString;
                  }
              }

              console.log("Contract string just before end: " + contractString);
              if (contractString !== "") {
                  console.log("6: Pushing " + contractString + " to contractsStack");
                  contractsStack.push(contractString);
              }
            }
            printStack(stack, "termStack");
            printStack(conjunctionStack, "conjunctionStack");
            printStack(contractsStack, "contractsStack");
            var res = contractsStack.length / conjunctionStack.length;

            while (conjunctionStack.length >= 1 && contractsStack.length >= 2 && res === 2) {
                var contract1 = contractsStack.pop();
                var contract2 = contractsStack.pop();
                var conj = conjunctionStack.pop();
                console.log("Combining leftover contracts...");
                console.log(contract1 + " " + conj + " " + contract2);
                if (conj === "or") {
                    createSection();
                    createButton(rTrimWhiteSpace(lTrimWhiteSpace(contract2)), 1);
                    createOrLabel();
                    createButton(rTrimWhiteSpace(lTrimWhiteSpace(contract1)), 2);
                }
                res = contractsStack.length / conjunctionStack.length;
            }
      }
      else {
          // String does not include "or" -> execute right away
      }
    }

  function printStack(stack, name) {
      console.log(name + ": " + stack.length);
      var x;
      for (x = 0; x < stack.length; ++x) {
          console.log(stack[x]);
      }
  }

  function createButton(contractString, buttonId) {
    var button = document.createElement("button");
    button.id = "choices_button_" + buttonId;
    button.innerHTML = cleanContractParens(contractString);
    // 2. Append somewhere
    var bottomContainer = document.getElementById("button_choices_container");
    bottomContainer.appendChild(button);

    // 3. Add event handler
    button.addEventListener ("click", function() {
        console.log("BUTTON PRESSED!!!");
        console.log(stringToAddToBeginning + button.innerHTML);
        // disable other button
        document.getElementById("choices_button_1").disabled = true;
        document.getElementById("choices_button_2").disabled = true;

        parse(button.innerHTML);
    });
  }

  function cleanContractParens(contractString) {
    if (contractString[contractString.length - 1] === "(") {
        contractString = contractString.slice(0, -1);
    }
    if (contractString[0] === ")") {
        contractString = contractString.substring(1);
    }
    if (openingParensAmount(contractString) > closingParensAmount(contractString)) {
        contractString = lTrimParen(contractString);
    } else if (openingParensAmount(contractString) < closingParensAmount(contractString)) {
        contractString = rTrimParen(contractString);
    }
    return contractString;

  }

  function openingParensAmount(string) {
      return string.split("(").length - 1;
  }

  function closingParensAmount(string) {
      return string.split(")").length - 1;
  }

  function createSection() {
      var para = document.createElement("p");
      var node = document.createTextNode("Contract choice:");
      para.appendChild(node);

      var bottomContainer = document.getElementById("button_choices_container");
      bottomContainer.appendChild(para);
  }

  function createOrLabel() {
      var para = document.createElement("p");
      para.className = "p_small";
      var node = document.createTextNode("OR");
      para.appendChild(node);

      var bottomContainer = document.getElementById("button_choices_container");
      bottomContainer.appendChild(para);
  }

  class Contract {

      constructor(recipient, amount, acquireAtHorizon, horizonDate) {
          this.recipient = recipient;
          this.amount = amount;
          this.acquireAtHorizon = acquireAtHorizon;
          this.horizonDate = horizonDate;
      }

      // Adding a method to the constructor
      greet() {
          return `${this.name} says hello.`;
      }

      printContract() {

          return `${this.name} says hello.`;
      }
  }


    function date(stringInput) {

        var matches = stringInput.match(/^((0?[1-9])|([12][0-9])|(3[01]))\/((0?[1-9])|(1[0-2]))\/(\d\d\d\d)-((0[0-9])|(1[0-9])|(2[0-3])):([0-5][0-9]):([0-5][0-9])$/);

        if (matches === null) {
            return false;
        } else if (matches[0] === stringInput) {
            return true;
        } else {
            return false;
        }
    }

    function lTrimWhiteSpace(str) {
      if(str == null) return str;
      return str.replace(/^\s+/g, '');
    }

    function rTrimWhiteSpace(str) {
      if(str == null) return str;
      return str.replace(/\s$/g, '');
    }

    function lTrimParen(str) {
      if(str == null) return str;
      return str.replace(/^\(+/g, '');
    }

    function rTrimParen(str) {
      if(str == null) return str;
      return str.replace(/\)$/g, '');
    }

    function lTrimDoubleQuotes(str) {
      if(str == null) return str;
      return str.replace(/^\"+/g, '');
    }

    function rTrimDoubleQuotes(str) {
      if(str == null) return str;
      return str.replace(/\"$/g, '');
    }
  </script>

</body>
